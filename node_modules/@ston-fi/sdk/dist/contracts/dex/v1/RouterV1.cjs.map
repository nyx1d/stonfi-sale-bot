{"version":3,"file":"RouterV1.cjs","sources":["../../../../src/contracts/dex/v1/RouterV1.ts"],"sourcesContent":["import {\n  type Cell,\n  type ContractProvider,\n  type Sender,\n  type SenderArguments,\n  address,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport { Contract, type ContractOptions } from \"@/contracts/core/Contract\";\nimport { JettonMinter } from \"@/contracts/core/JettonMinter\";\nimport type { Pton } from \"@/contracts/pTON/types\";\nimport type { AddressType, AmountType, QueryIdType } from \"@/types\";\nimport { createJettonTransferMessage } from \"@/utils/createJettonTransferMessage\";\nimport { toAddress } from \"@/utils/toAddress\";\n\nimport { DEX_OP_CODES, DEX_VERSION } from \"../constants\";\n\nimport { PoolV1 } from \"./PoolV1\";\n\nexport interface RouterV1Options extends ContractOptions {\n  gasConstants?: Partial<typeof RouterV1.gasConstants>;\n}\n\n/**\n * The router is the contract that acts as an entrypoint for all DEX calls.\n * It is responsible for routing all Jetton calls with transfer_notification op to the correct pool contract.\n * It acts as a sovereign over the DEX, and can be used to lock/unlock trading on all pools,\n * to change fees on a certain pool or to upgrade its own contract. The router is the only contract that can be upgraded.\n * Each Jetton that goes through the DEX is owned by the router. The router does not store anything about pairs.\n */\nexport class RouterV1 extends Contract {\n  public static readonly version = DEX_VERSION.v1;\n  public static readonly address = address(\n    \"EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt\",\n  );\n  public static readonly gasConstants = {\n    swapJettonToJetton: {\n      gasAmount: toNano(\"0.22\"),\n      forwardGasAmount: toNano(\"0.175\"),\n    },\n    swapJettonToTon: {\n      gasAmount: toNano(\"0.17\"),\n      forwardGasAmount: toNano(\"0.125\"),\n    },\n    swapTonToJetton: {\n      forwardGasAmount: toNano(\"0.185\"),\n    },\n    provideLpJetton: {\n      gasAmount: toNano(\"0.3\"),\n      forwardGasAmount: toNano(\"0.24\"),\n    },\n    provideLpTon: {\n      forwardGasAmount: toNano(\"0.26\"),\n    },\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType = RouterV1.address,\n    { gasConstants, ...options }: RouterV1Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...RouterV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createSwapBody(params: {\n    userWalletAddress: AddressType;\n    minAskAmount: AmountType;\n    askJettonWalletAddress: AddressType;\n    referralAddress?: AddressType;\n  }): Promise<Cell> {\n    const builder = beginCell();\n\n    builder.storeUint(DEX_OP_CODES.SWAP, 32);\n    builder.storeAddress(toAddress(params.askJettonWalletAddress));\n    builder.storeCoins(BigInt(params.minAskAmount));\n    builder.storeAddress(toAddress(params.userWalletAddress));\n\n    if (params.referralAddress) {\n      builder.storeUint(1, 1);\n      builder.storeAddress(toAddress(params.referralAddress));\n    } else {\n      builder.storeUint(0, 1);\n    }\n\n    return builder.endCell();\n  }\n\n  /**\n   * Build all data required to execute a jetton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {bigint | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} data required to execute a jetton `swap` transaction\n   */\n  public async getSwapJettonToJettonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      offerJettonAddress: AddressType;\n      askJettonAddress: AddressType;\n      offerAmount: AmountType;\n      minAskAmount: AmountType;\n      referralAddress?: AddressType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const [offerJettonWalletAddress, askJettonWalletAddress] =\n      await Promise.all([\n        provider\n          .open(JettonMinter.create(params.offerJettonAddress))\n          .getWalletAddress(params.userWalletAddress),\n        provider\n          .open(JettonMinter.create(params.askJettonAddress))\n          .getWalletAddress(this.address),\n      ]);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.swapJettonToJetton.forwardGasAmount,\n    );\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: this.address,\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = BigInt(\n      params.gasAmount ?? this.gasConstants.swapJettonToJetton.gasAmount,\n    );\n\n    return {\n      to: offerJettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendSwapJettonToJetton(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getSwapJettonToJettonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getSwapJettonToJettonTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Build all data required to execute a jetton to ton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.proxyTon - Proxy ton contract\n   * @param {bigint | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} data required to execute a jetton `swap` transaction\n   */\n  public async getSwapJettonToTonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      offerJettonAddress: AddressType;\n      proxyTon: Pton;\n      offerAmount: AmountType;\n      minAskAmount: AmountType;\n      referralAddress?: AddressType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    return await this.getSwapJettonToJettonTxParams(provider, {\n      ...params,\n      askJettonAddress: params.proxyTon.address,\n      gasAmount:\n        params.gasAmount ?? this.gasConstants.swapJettonToTon.gasAmount,\n      forwardGasAmount:\n        params.forwardGasAmount ??\n        this.gasConstants.swapJettonToTon.forwardGasAmount,\n    });\n  }\n\n  public async sendSwapJettonToTon(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getSwapJettonToTonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getSwapJettonToTonTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Build all data required to execute a ton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTon - Proxy ton contract\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {bigint | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)\n   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; Referral address\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} data required to execute a ton to jetton `swap` transaction\n   */\n  public async getSwapTonToJettonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      proxyTon: Pton;\n      askJettonAddress: AddressType;\n      offerAmount: AmountType;\n      minAskAmount: AmountType;\n      referralAddress?: AddressType | undefined;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const askJettonWalletAddress = await provider\n      .open(JettonMinter.create(params.askJettonAddress))\n      .getWalletAddress(this.address);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.swapTonToJetton.forwardGasAmount,\n    );\n\n    return await provider.open(params.proxyTon).getTonTransferTxParams({\n      queryId: params.queryId ?? 0,\n      tonAmount: params.offerAmount,\n      destinationAddress: this.address,\n      refundAddress: params.userWalletAddress,\n      forwardPayload,\n      forwardTonAmount,\n    });\n  }\n\n  public async sendSwapTonToJetton(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getSwapTonToJettonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getSwapTonToJettonTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  public async createProvideLiquidityBody(params: {\n    routerWalletAddress: AddressType;\n    minLpOut: AmountType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(DEX_OP_CODES.PROVIDE_LP, 32)\n      .storeAddress(toAddress(params.routerWalletAddress))\n      .storeCoins(BigInt(params.minLpOut))\n      .endCell();\n  }\n\n  /**\n   * Collect all data required to execute a jetton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {bigint | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)\n   * @param {bigint | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} data required to execute a jetton `provide_lp` transaction\n   */\n  public async getProvideLiquidityJettonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      sendTokenAddress: AddressType;\n      otherTokenAddress: AddressType;\n      sendAmount: AmountType;\n      minLpOut: AmountType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const [jettonWalletAddress, routerWalletAddress] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.sendTokenAddress))\n        .getWalletAddress(params.userWalletAddress),\n      provider\n        .open(JettonMinter.create(params.otherTokenAddress))\n        .getWalletAddress(this.address),\n    ]);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpJetton.forwardGasAmount,\n    );\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: this.address,\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = BigInt(\n      params.gasAmount ?? this.gasConstants.provideLpJetton.gasAmount,\n    );\n\n    return {\n      to: jettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendProvideLiquidityJetton(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getProvideLiquidityJettonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getProvideLiquidityJettonTxParams(\n      provider,\n      params,\n    );\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Collect all data required to execute a proxy ton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTon - proxy ton contract\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {bigint | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)\n   * @param {bigint | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} data required to execute a proxy ton `provide_lp` transaction\n   */\n  public async getProvideLiquidityTonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      proxyTon: Pton;\n      otherTokenAddress: AddressType;\n      sendAmount: AmountType;\n      minLpOut: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const routerWalletAddress = await provider\n      .open(JettonMinter.create(params.otherTokenAddress))\n      .getWalletAddress(this.address);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpTon.forwardGasAmount,\n    );\n\n    return await provider.open(params.proxyTon).getTonTransferTxParams({\n      queryId: params.queryId ?? 0,\n      tonAmount: params.sendAmount,\n      destinationAddress: this.address,\n      refundAddress: params.userWalletAddress,\n      forwardPayload,\n      forwardTonAmount,\n    });\n  }\n\n  public async sendProvideLiquidityTon(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getProvideLiquidityTonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getProvideLiquidityTonTxParams(\n      provider,\n      params,\n    );\n\n    return via.send(txParams);\n  }\n\n  /**\n   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.\n   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.\n   *\n   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton\n   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton\n   *\n   * @returns {Address} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddress(\n    provider: ContractProvider,\n    params: {\n      token0: AddressType;\n      token1: AddressType;\n    },\n  ) {\n    const result = await provider.get(\"get_pool_address\", [\n      {\n        type: \"slice\",\n        cell: beginCell().storeAddress(toAddress(params.token0)).endCell(),\n      },\n      {\n        type: \"slice\",\n        cell: beginCell().storeAddress(toAddress(params.token1)).endCell(),\n      },\n    ]);\n\n    return result.stack.readAddress();\n  }\n\n  /**\n   * @param {Address | string} params.token0 - The address of the first Jetton minter\n   * @param {Address | string} params.token1 - The address of the second Jetton minter\n   *\n   * @returns {Address} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddressByJettonMinters(\n    provider: ContractProvider,\n    params: {\n      token0: AddressType;\n      token1: AddressType;\n    },\n  ) {\n    const [jetton0WalletAddress, jetton1WalletAddress] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.token0))\n        .getWalletAddress(this.address),\n      provider\n        .open(JettonMinter.create(params.token1))\n        .getWalletAddress(this.address),\n    ]);\n\n    const poolAddress = await this.getPoolAddress(provider, {\n      token0: jetton0WalletAddress,\n      token1: jetton1WalletAddress,\n    });\n\n    return poolAddress;\n  }\n\n  /**\n   * @param {Address | string} params.token0 - The address of the first Jetton minter\n   * @param {Address | string} params.token1 - The address of the second Jetton minter\n   *\n   * @returns {PoolV1} object for a pool with specified Jetton token addresses.\n   */\n  public async getPool(\n    provider: ContractProvider,\n    params: {\n      token0: AddressType;\n      token1: AddressType;\n    },\n  ) {\n    const poolAddress = await this.getPoolAddressByJettonMinters(provider, {\n      token0: params.token0,\n      token1: params.token1,\n    });\n\n    return PoolV1.create(poolAddress);\n  }\n\n  /**\n   * @returns current state of the router.\n   */\n  public async getRouterData(provider: ContractProvider) {\n    const result = await provider.get(\"get_router_data\", []);\n\n    return {\n      isLocked: result.stack.readBoolean(),\n      adminAddress: result.stack.readAddress(),\n      tempUpgrade: result.stack.readCell(),\n      poolCode: result.stack.readCell(),\n      jettonLpWalletCode: result.stack.readCell(),\n      lpAccountCode: result.stack.readCell(),\n    };\n  }\n}\n"],"names":["_RouterV1","Contract","address","beginCell","DEX_OP_CODES","toAddress","JettonMinter","createJettonTransferMessage","PoolV1","DEX_VERSION","toNano"],"mappings":"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"}