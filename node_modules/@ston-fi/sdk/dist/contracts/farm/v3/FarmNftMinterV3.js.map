{"version":3,"file":"FarmNftMinterV3.js","sources":["../../../../src/contracts/farm/v3/FarmNftMinterV3.ts"],"sourcesContent":["import {\n  type Address,\n  type Cell,\n  type ContractProvider,\n  type Sender,\n  type SenderArguments,\n  Dictionary,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport { Contract, type ContractOptions } from \"@/contracts/core/Contract\";\nimport { JettonMinter } from \"@/contracts/core/JettonMinter\";\nimport { JettonWallet } from \"@/contracts/core/JettonWallet\";\nimport type { AddressType, AmountType, QueryIdType } from \"@/types\";\nimport { createJettonTransferMessage } from \"@/utils/createJettonTransferMessage\";\nimport { toAddress } from \"@/utils/toAddress\";\n\nimport { FARM_OP_CODES, FARM_VERSION } from \"../constants\";\n\n/**\n *  @type {FarmDataAccrued} represent state of the accrued data for pool\n *\n * @property {bigint} depositedNanorewards - Deposited rewards in nanounits\n * @property {bigint} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit\n * @property {bigint} accruedFeeNanorewards - Accrued fees\n * @property {bigint} claimedNanorewards - Number of claimed rewards in nanounits\n * @property {bigint} claimedFeeNanorewards - Claimed fees\n * @property {bigint} accruedNanorewards - Total number of accrued rewards in nanounits\n * @property {bigint} lastUpdateTime - Last time farming values were updated\n */\nexport type FarmDataAccrued = {\n  depositedNanorewards: bigint;\n  accruedPerUnitNanorewards: bigint;\n  accruedFeeNanorewards: bigint;\n  claimedNanorewards: bigint;\n  claimedFeeNanorewards: bigint;\n  accruedNanorewards: bigint;\n  lastUpdateTime: bigint;\n};\n\n/**\n *  @type {FarmDataParameters} represent state of the pool parameters\n *\n * @property {bigint} adminFee - Admin fee; divider is 10000\n * @property {bigint} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits\n * @property {boolean} unrestrictedDepositRewards - If rewards can be deposited by anyone\n * @property {Address} rewardTokenWallet - Minter's reward jetton wallet\n * @property {boolean} canChangeFee - If can change fee\n * @property {bigint} status - Status of the contract\n */\nexport type FarmDataParameters = {\n  adminFee: bigint;\n  nanorewardsPer24h: bigint;\n  unrestrictedDepositRewards: boolean;\n  rewardTokenWallet: Address;\n  canChangeFee: boolean;\n  status: number;\n};\n\nexport interface FarmNftMinterV3Options extends ContractOptions {\n  gasConstants?: Partial<typeof FarmNftMinterV3.gasConstants>;\n}\n\nexport class FarmNftMinterV3 extends Contract {\n  public static readonly version: FARM_VERSION = FARM_VERSION.v3;\n\n  public static readonly gasConstants = {\n    stakeFwdBase: toNano(\"0.21\"),\n    stakeFwdPerPool: toNano(\"0.015\"),\n    stake: toNano(\"0.1\"),\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType,\n    { gasConstants, ...options }: FarmNftMinterV3Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...FarmNftMinterV3.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createStakeBody(params?: {\n    ownerAddress?: AddressType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(FARM_OP_CODES.STAKE, 32)\n      .storeAddress(\n        params?.ownerAddress ? toAddress(params.ownerAddress) : undefined,\n      )\n      .endCell();\n  }\n\n  /**\n   * Build all data required to execute a jetton `stake` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked\n   * @param {bigint | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)\n   * @param {number | undefined} params.poolCount - Optional; Number of deployed farm reward pools; If undefined value will get onchain\n   * @param {Address | string} params.ownerAddress - Optional; custom owner of stake; if undefined stake owner is sender address\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} containing all data required to execute a jetton `stake` transaction\n   */\n  public async getStakeTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      jettonAddress: AddressType;\n      jettonAmount: AmountType;\n      poolCount?: number;\n      ownerAddress?: AddressType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const [jettonWalletAddress, forwardPayload, poolCount] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.jettonAddress))\n        .getWalletAddress(params.userWalletAddress),\n      this.createStakeBody({\n        ownerAddress: params.ownerAddress,\n      }),\n      (async () =>\n        params.poolCount ??\n        (await this.getFarmingMinterData(provider)).poolCount)(),\n    ]);\n\n    const forwardTonAmount =\n      this.gasConstants.stakeFwdBase +\n      this.gasConstants.stakeFwdPerPool * BigInt(poolCount + 1);\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.jettonAmount,\n      destination: this.address,\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = forwardTonAmount + this.gasConstants.stake;\n\n    return {\n      to: jettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendStake(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<FarmNftMinterV3[\"getStakeTxParams\"]>[1],\n  ) {\n    const txParams = await this.getStakeTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * @returns {Address} address of minter for staking jetton that is used for farming\n   */\n  public async getStakingJettonAddress(\n    provider: ContractProvider,\n  ): Promise<Address> {\n    const { stakingTokenWallet: stakingTokenWalletAddress } =\n      await this.getFarmingMinterData(provider);\n\n    const { jettonMasterAddress } = await provider\n      .open(JettonWallet.create(stakingTokenWalletAddress))\n      .getWalletData();\n\n    return jettonMasterAddress;\n  }\n\n  /**\n   * @returns structure containing pending data\n   *\n   * @property {bigint} changeCustodianTs - Timestamp when 'change_custodian' was initiated\n   * @property {bigint} sendMsgTs - Timestamp when 'send_raw_msg' was initiated\n   * @property {bigint} codeUpgradeTs - Timestamp when 'code_upgrade' was initiated\n   * @property {Address} newCustodian - New custodian that will be set after confirmation\n   * @property {Cell} pendingMsg - Pending msg that will be sends after confirmation\n   * @property {Cell} newCode - New contract code that will be set after confirmation\n   * @property {Cell} newStorage - New contract storage that will be set after confirmation\n   */\n  public async getPendingData(provider: ContractProvider) {\n    const result = await provider.get(\"get_pending_data\", []);\n\n    return {\n      changeCustodianTs: result.stack.readBigNumber(),\n      sendMsgTs: result.stack.readBigNumber(),\n      codeUpgradeTs: result.stack.readBigNumber(),\n      newCustodian: result.stack.readAddressOpt(),\n      pendingMsg: result.stack.readCell(),\n      newCode: result.stack.readCell(),\n      newStorage: result.stack.readCell(),\n    };\n  }\n\n  /**\n   * @returns structure containing version data\n   *\n   * @property {number} major - Major version; breaking changes in api\n   * @property {number} minor - Minor version; non-breaking new functionality\n   * @property {string} development - Development version; can contain breaking changes\n   */\n  public async getVersion(provider: ContractProvider) {\n    const result = await provider.get(\"get_version\", []);\n\n    return {\n      major: result.stack.readNumber(),\n      minor: result.stack.readNumber(),\n      development: result.stack.readString(),\n    };\n  }\n\n  /**\n   * @returns structure containing current state of the minter\n   *\n   * @property {bigint} nextItemIndex - Index of the next nft in this collection\n   * @property {number} status - Status of the contract: uninitialized `0`, operational `1`, pause_all `2`, frozen `3`, retired `4`,\n   * @property {number} poolCount - Pools count\n   * @property {bigint} currentStakedTokens - Number of staked tokens in basic token units\n   * @property {bigint} contractUniqueId - Minter id\n   * @property {bigint} minStakeTime - Minimum staking time\n   * @property {Address} stakingTokenWallet - Minter's staking jetton wallet\n   * @property {Address} custodianAddress - Custodian address\n   * @property {boolean} canChangeCustodian - If can change custodian\n   * @property {boolean} canSendRawMsg - If admin can send arbitrary raw msg from Minter\n   * @property {Map<number, FarmDataAccrued>} farmDataAccrued - Accrued data for pools\n   * @property {Map<number, FarmDataParameters>} farmDataParameters - Pools parameters\n   */\n  public async getFarmingMinterData(provider: ContractProvider) {\n    const result = await provider.get(\"get_farming_minter_data\", []);\n\n    return {\n      nextItemIndex: result.stack.readBigNumber(),\n      status: result.stack.readNumber(),\n      poolCount: result.stack.readNumber(),\n      currentStakedTokens: result.stack.readBigNumber(),\n      contractUniqueId: result.stack.readBigNumber(),\n      minStakeTime: result.stack.readBigNumber(),\n      stakingTokenWallet: result.stack.readAddress(),\n      custodianAddress: result.stack.readAddress(),\n      canChangeCustodian: result.stack.readBoolean(),\n      canSendRawMsg: result.stack.readBoolean(),\n      farmDataAccrued: (() => {\n        const dict = result.stack\n          .readCell()\n          .asSlice()\n          .loadDictDirect(Dictionary.Keys.Uint(8), Dictionary.Values.Cell());\n\n        const farmDataAccrued = new Map<number, FarmDataAccrued>();\n\n        for (const poolIndex of dict.keys()) {\n          const cell = dict.get(poolIndex);\n\n          if (!cell)\n            throw new Error(\n              `Failed to parse farmDataAccrued from dict: ${dict}`,\n            );\n\n          const slice = cell.beginParse();\n\n          const accruedData = {\n            depositedNanorewards: slice.loadUintBig(150),\n            accruedPerUnitNanorewards: slice.loadUintBig(150),\n            accruedFeeNanorewards: slice.loadUintBig(150),\n            claimedNanorewards: slice.loadUintBig(150),\n            claimedFeeNanorewards: slice.loadUintBig(150),\n            accruedNanorewards: slice.loadUintBig(150),\n            lastUpdateTime: slice.loadUintBig(64),\n          };\n\n          farmDataAccrued.set(poolIndex, accruedData);\n        }\n\n        return farmDataAccrued;\n      })(),\n      farmDataParameters: (() => {\n        const dict = result.stack\n          .readCell()\n          .asSlice()\n          .loadDictDirect(Dictionary.Keys.Uint(8), Dictionary.Values.Cell());\n\n        const farmDataParameters = new Map<number, FarmDataParameters>();\n\n        for (const poolIndex of dict.keys()) {\n          const cell = dict.get(poolIndex);\n\n          if (!cell)\n            throw new Error(\n              `Failed to parse farmDataParameters from dict: ${dict}`,\n            );\n\n          const slice = cell.beginParse();\n\n          const parametersData = {\n            adminFee: slice.loadUintBig(16),\n            nanorewardsPer24h: slice.loadUintBig(150),\n            unrestrictedDepositRewards: slice.loadBit(),\n            rewardTokenWallet: slice.loadAddress(),\n            canChangeFee: slice.loadBit(),\n            status: slice.loadUint(8),\n          };\n          farmDataParameters.set(poolIndex, parametersData);\n        }\n\n        return farmDataParameters;\n      })(),\n    };\n  }\n}\n"],"names":["_FarmNftMinterV3"],"mappings":"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"}