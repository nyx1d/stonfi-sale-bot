{"version":3,"file":"FarmNftItemV3.cjs","sources":["../../../../src/contracts/farm/v3/FarmNftItemV3.ts"],"sourcesContent":["import {\n  type Cell,\n  type ContractProvider,\n  type Sender,\n  type SenderArguments,\n  Dictionary,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport { Contract, type ContractOptions } from \"@/contracts/core/Contract\";\nimport type { AddressType, QueryIdType } from \"@/types\";\nimport { createSbtDestroyMessage } from \"@/utils/createSbtDestroyMessage\";\n\nimport { FARM_OP_CODES, FARM_VERSION } from \"../constants\";\n\nimport { FarmNftMinterV3 } from \"./FarmNftMinterV3\";\n\nexport interface FarmNftItemV3Options extends ContractOptions {\n  gasConstants?: Partial<typeof FarmNftItemV3.gasConstants>;\n}\n\nexport class FarmNftItemV3 extends Contract {\n  public static readonly version = FARM_VERSION.v3;\n\n  public static readonly gasConstants = {\n    claimRewardsBase: toNano(\"0.35\"),\n    claimRewardsPerPool: toNano(\"0.13\"),\n    unstakeBase: toNano(\"0.45\"),\n    unstakePerPool: toNano(\"0.13\"),\n    destroy: toNano(\"0.05\"),\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType,\n    { gasConstants, ...options }: FarmNftItemV3Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...FarmNftItemV3.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createClaimRewardsBody(\n    params: {\n      queryId?: QueryIdType;\n    } & (\n      | {\n          claimAll: true;\n        }\n      | {\n          claimAll: false;\n          poolIndex: number;\n        }\n    ),\n  ): Promise<Cell> {\n    const builder = beginCell();\n\n    builder.storeUint(FARM_OP_CODES.CLAIM_REWARDS, 32);\n    builder.storeUint(params.queryId ?? 0, 64);\n\n    if (params.claimAll) {\n      builder.storeUint(1, 1);\n      builder.storeUint(0, 8);\n    } else {\n      builder.storeUint(0, 1);\n      builder.storeUint(params.poolIndex, 8);\n    }\n\n    return builder.endCell();\n  }\n\n  /**\n   * Build all data required to execute a `claim_rewards` transaction.\n   *\n   * @param {number | undefined} params.poolCount - Optional; Number of deployed farm reward pools; If undefined value will get onchain\n   * @param {number | undefined} params.poolIndex - Optional; farm reward pool index used for claiming; If undefined claim rewards from all pools\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} all data required to execute a `claim_rewards` transaction.\n   */\n  public async getClaimRewardsTxParams(\n    provider: ContractProvider,\n    params?: {\n      poolCount?: number;\n      queryId?: QueryIdType;\n      poolIndex?: number;\n    },\n  ): Promise<SenderArguments> {\n    const to = this.address;\n\n    const body = await this.createClaimRewardsBody({\n      queryId: params?.queryId,\n      claimAll: params?.poolIndex === undefined,\n      poolIndex: params?.poolIndex ?? 0,\n    });\n\n    const poolCount = params?.poolCount ?? (await this.getPoolCount(provider));\n\n    const value =\n      this.gasConstants.claimRewardsBase +\n      this.gasConstants.claimRewardsPerPool * BigInt(poolCount - 1);\n\n    return { to, value, body };\n  }\n\n  public async sendClaimRewards(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<FarmNftItemV3[\"getClaimRewardsTxParams\"]>[1],\n  ) {\n    const txParams = await this.getClaimRewardsTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  public async createUnstakeBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(FARM_OP_CODES.UNSTAKE, 32)\n      .storeUint(params?.queryId ?? 0, 64)\n      .endCell();\n  }\n\n  /**\n   * Build all data required to execute a `unstake` transaction.\n   *\n   * @param {number | undefined} params.poolCount -  Optional; Number of deployed farm reward pools; If undefined value will get onchain\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} all data required to execute a `unstake` transaction.\n   */\n  public async getUnstakeTxParams(\n    provider: ContractProvider,\n    params?: {\n      poolCount?: number;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const to = this.address;\n\n    const body = await this.createUnstakeBody({\n      queryId: params?.queryId,\n    });\n\n    const poolCount = params?.poolCount ?? (await this.getPoolCount(provider));\n\n    const value =\n      this.gasConstants.unstakeBase +\n      this.gasConstants.unstakePerPool * BigInt(poolCount - 1);\n\n    return { to, value, body };\n  }\n\n  public async sendUnstake(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<FarmNftItemV3[\"getUnstakeTxParams\"]>[1],\n  ) {\n    const txParams = await this.getUnstakeTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  public async createDestroyBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return createSbtDestroyMessage({\n      queryId: params?.queryId ?? 0,\n    });\n  }\n\n  /**\n   * Build all data required to execute a `destroy` transaction.\n   *\n   * @param {bigint | string | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} all data required to execute a `destroy` transaction.\n   */\n  public async getDestroyTxParams(\n    provider: ContractProvider,\n    params?: {\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const to = this.address;\n\n    const body = await this.createDestroyBody({\n      queryId: params?.queryId,\n    });\n\n    const value = this.gasConstants.destroy;\n\n    return { to, value, body };\n  }\n\n  public async sendDestroy(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<FarmNftItemV3[\"getDestroyTxParams\"]>[1],\n  ) {\n    const txParams = await this.getDestroyTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * @returns structure containing current state of the farm NFT\n   *\n   * @property {number} status Status of the contract: uninitialized (0), active (1), unstaked (2), claiming (3), unstaked_pending (4)\n   * @property {bigint} revokeTime Timestamp of unstake\n   * @property {bigint} stakedTokens Amount of staked tokens\n   * @property {bigint} stakeDate Timestamp in which the owner started staking\n   * @property {Map<number, bigint>} claimedPerUnit `accrued_per_unit_nanorewards amounts` for each pool at the time of last claim for this user\n   * @property {Address} ownerAddress Owner address of farm nft\n   */\n  public async getFarmingData(provider: ContractProvider) {\n    const result = await provider.get(\"get_farming_data\", []);\n\n    return {\n      status: result.stack.readNumber(),\n      revokeTime: result.stack.readBigNumber(),\n      stakedTokens: result.stack.readBigNumber(),\n      stakeDate: result.stack.readBigNumber(),\n      claimedPerUnit: (() => {\n        const dict = result.stack\n          .readCell()\n          .asSlice()\n          .loadDictDirect(\n            Dictionary.Keys.Uint(8),\n            Dictionary.Values.BigUint(150),\n          );\n\n        const claimedPerUnit = new Map<number, bigint>();\n\n        for (const poolIndex of dict.keys()) {\n          const accruedPerUnitNanorewards = dict.get(poolIndex);\n\n          if (!accruedPerUnitNanorewards)\n            throw new Error(\n              `Failed to parse claimedPerUnit from dict: ${dict}`,\n            );\n\n          claimedPerUnit.set(Number(poolIndex), accruedPerUnitNanorewards);\n        }\n\n        return claimedPerUnit;\n      })(),\n      ownerAddress: result.stack.readAddress(),\n    };\n  }\n\n  public async getPoolCount(provider: ContractProvider) {\n    const result = await provider.get(\"get_nft_data\", []);\n\n    const nftItemData = {\n      isInitialized: result.stack.readBoolean(),\n      index: result.stack.readNumber(),\n      minterAddress: result.stack.readAddress(),\n    };\n\n    const { poolCount } = await provider\n      .open(FarmNftMinterV3.create(nftItemData.minterAddress))\n      .getFarmingMinterData();\n\n    return poolCount;\n  }\n}\n"],"names":["_FarmNftItemV3","Contract","beginCell","FARM_OP_CODES","createSbtDestroyMessage","Dictionary","FarmNftMinterV3","FARM_VERSION","toNano"],"mappings":"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"}