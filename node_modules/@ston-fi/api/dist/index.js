const k = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, ee = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, te = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function re(e, t) {
  if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype" in t) {
    se(e);
    return;
  }
  return t;
}
function se(e) {
  console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`);
}
function oe(e, t = {}) {
  if (typeof e != "string")
    return e;
  const r = e.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    e[0] === '"' && e.at(-1) === '"' && !e.includes("\\")
  )
    return r.slice(1, -1);
  if (r.length <= 9) {
    const s = r.toLowerCase();
    if (s === "true")
      return !0;
    if (s === "false")
      return !1;
    if (s === "undefined")
      return;
    if (s === "null")
      return null;
    if (s === "nan")
      return Number.NaN;
    if (s === "infinity")
      return Number.POSITIVE_INFINITY;
    if (s === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!te.test(e)) {
    if (t.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return e;
  }
  try {
    if (k.test(e) || ee.test(e)) {
      if (t.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(e, re);
    }
    return JSON.parse(e);
  } catch (s) {
    if (t.strict)
      throw s;
    return e;
  }
}
const ne = /#/g, ae = /&/g, ce = /=/g, C = /\+/g, ie = /%5e/gi, fe = /%60/gi, he = /%7c/gi, le = /%20/gi;
function ue(e) {
  return encodeURI("" + e).replace(he, "|");
}
function w(e) {
  return ue(typeof e == "string" ? e : JSON.stringify(e)).replace(C, "%2B").replace(le, "+").replace(ne, "%23").replace(ae, "%26").replace(fe, "`").replace(ie, "^");
}
function g(e) {
  return w(e).replace(ce, "%3D");
}
function G(e = "") {
  try {
    return decodeURIComponent("" + e);
  } catch {
    return "" + e;
  }
}
function pe(e) {
  return G(e.replace(C, " "));
}
function de(e) {
  return G(e.replace(C, " "));
}
function ye(e = "") {
  const t = {};
  e[0] === "?" && (e = e.slice(1));
  for (const r of e.split("&")) {
    const s = r.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2)
      continue;
    const n = pe(s[1]);
    if (n === "__proto__" || n === "constructor")
      continue;
    const a = de(s[2] || "");
    t[n] === void 0 ? t[n] = a : Array.isArray(t[n]) ? t[n].push(a) : t[n] = [t[n], a];
  }
  return t;
}
function me(e, t) {
  return (typeof t == "number" || typeof t == "boolean") && (t = String(t)), t ? Array.isArray(t) ? t.map((r) => `${g(e)}=${w(r)}`).join("&") : `${g(e)}=${w(t)}` : g(e);
}
function ge(e) {
  return Object.keys(e).filter((t) => e[t] !== void 0).map((t) => me(t, e[t])).filter(Boolean).join("&");
}
const _e = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/, Ee = /^[\s\w\0+.-]{2,}:([/\\]{2})?/, we = /^([/\\]\s*){2,}[^/\\]/;
function J(e, t = {}) {
  return typeof t == "boolean" && (t = { acceptRelative: t }), t.strict ? _e.test(e) : Ee.test(e) || (t.acceptRelative ? we.test(e) : !1);
}
const Ae = /\/$|\/\?|\/#/;
function A(e = "", t) {
  return t ? Ae.test(e) : e.endsWith("/");
}
function be(e = "", t) {
  if (!t)
    return (A(e) ? e.slice(0, -1) : e) || "/";
  if (!A(e, !0))
    return e || "/";
  let r = e, s = "";
  const n = e.indexOf("#");
  n >= 0 && (r = e.slice(0, n), s = e.slice(n));
  const [a, ...i] = r.split("?");
  return (a.slice(0, -1) || "/") + (i.length > 0 ? `?${i.join("?")}` : "") + s;
}
function Re(e = "", t) {
  if (!t)
    return e.endsWith("/") ? e : e + "/";
  if (A(e, !0))
    return e || "/";
  let r = e, s = "";
  const n = e.indexOf("#");
  if (n >= 0 && (r = e.slice(0, n), s = e.slice(n), !r))
    return s;
  const [a, ...i] = r.split("?");
  return a + "/" + (i.length > 0 ? `?${i.join("?")}` : "") + s;
}
function Ce(e, t) {
  if (Le(t) || J(e))
    return e;
  const r = be(t);
  return e.startsWith(r) ? e : Oe(r, e);
}
function Te(e, t) {
  const r = K(e), s = { ...ye(r.search), ...t };
  return r.search = ge(s), $e(r);
}
function Le(e) {
  return !e || e === "/";
}
function Ie(e) {
  return e && e !== "/";
}
const Se = /^\.?\//;
function Oe(e, ...t) {
  let r = e || "";
  for (const s of t.filter((n) => Ie(n)))
    if (r) {
      const n = s.replace(Se, "");
      r = Re(r) + n;
    } else
      r = s;
  return r;
}
function K(e = "", t) {
  const r = e.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (r) {
    const [, l, u = ""] = r;
    return {
      protocol: l.toLowerCase(),
      pathname: u,
      href: l + u,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!J(e, { acceptRelative: !0 }))
    return t ? K(t + e) : S(e);
  const [, s = "", n, a = ""] = e.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [], [, i = "", c = ""] = a.match(/([^#/?]*)(.*)?/) || [], { pathname: f, search: h, hash: o } = S(
    c.replace(/\/(?=[A-Za-z]:)/, "")
  );
  return {
    protocol: s.toLowerCase(),
    auth: n ? n.slice(0, Math.max(0, n.length - 1)) : "",
    host: i,
    pathname: f,
    search: h,
    hash: o
  };
}
function S(e = "") {
  const [t = "", r = "", s = ""] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname: t,
    search: r,
    hash: s
  };
}
function $e(e) {
  const t = e.pathname || "", r = e.search ? (e.search.startsWith("?") ? "" : "?") + e.search : "", s = e.hash || "", n = e.auth ? e.auth + "@" : "", a = e.host || "";
  return (e.protocol ? e.protocol + "//" : "") + n + a + t + r + s;
}
class xe extends Error {
  constructor(t, r) {
    super(t, r), this.name = "FetchError", r != null && r.cause && !this.cause && (this.cause = r.cause);
  }
}
function Ne(e) {
  var f, h, o, l, u;
  const t = ((f = e.error) == null ? void 0 : f.message) || ((h = e.error) == null ? void 0 : h.toString()) || "", r = ((o = e.request) == null ? void 0 : o.method) || ((l = e.options) == null ? void 0 : l.method) || "GET", s = ((u = e.request) == null ? void 0 : u.url) || String(e.request) || "/", n = `[${r}] ${JSON.stringify(s)}`, a = e.response ? `${e.response.status} ${e.response.statusText}` : "<no response>", i = `${n}: ${a}${t ? ` ${t}` : ""}`, c = new xe(
    i,
    e.error ? { cause: e.error } : void 0
  );
  for (const p of ["request", "options", "response"])
    Object.defineProperty(c, p, {
      get() {
        return e[p];
      }
    });
  for (const [p, m] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ])
    Object.defineProperty(c, p, {
      get() {
        return e.response && e.response[m];
      }
    });
  return c;
}
const Pe = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function O(e = "GET") {
  return Pe.has(e.toUpperCase());
}
function Ue(e) {
  if (e === void 0)
    return !1;
  const t = typeof e;
  return t === "string" || t === "number" || t === "boolean" || t === null ? !0 : t !== "object" ? !1 : Array.isArray(e) ? !0 : e.buffer ? !1 : e.constructor && e.constructor.name === "Object" || typeof e.toJSON == "function";
}
const je = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]), qe = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function ze(e = "") {
  if (!e)
    return "json";
  const t = e.split(";").shift() || "";
  return qe.test(t) ? "json" : je.has(t) || t.startsWith("text/") ? "text" : "blob";
}
function Fe(e, t, r = globalThis.Headers) {
  const s = {
    ...t,
    ...e
  };
  if (t != null && t.params && (e != null && e.params) && (s.params = {
    ...t == null ? void 0 : t.params,
    ...e == null ? void 0 : e.params
  }), t != null && t.query && (e != null && e.query) && (s.query = {
    ...t == null ? void 0 : t.query,
    ...e == null ? void 0 : e.query
  }), t != null && t.headers && (e != null && e.headers)) {
    s.headers = new r((t == null ? void 0 : t.headers) || {});
    for (const [n, a] of new r((e == null ? void 0 : e.headers) || {}))
      s.headers.set(n, a);
  }
  return s;
}
const ve = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  //  Gateway Timeout
]), De = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function V(e = {}) {
  const {
    fetch: t = globalThis.fetch,
    Headers: r = globalThis.Headers,
    AbortController: s = globalThis.AbortController
  } = e;
  async function n(c) {
    const f = c.error && c.error.name === "AbortError" && !c.options.timeout || !1;
    if (c.options.retry !== !1 && !f) {
      let o;
      typeof c.options.retry == "number" ? o = c.options.retry : o = O(c.options.method) ? 0 : 1;
      const l = c.response && c.response.status || 500;
      if (o > 0 && (Array.isArray(c.options.retryStatusCodes) ? c.options.retryStatusCodes.includes(l) : ve.has(l))) {
        const u = c.options.retryDelay || 0;
        return u > 0 && await new Promise((p) => setTimeout(p, u)), a(c.request, {
          ...c.options,
          retry: o - 1,
          timeout: c.options.timeout
        });
      }
    }
    const h = Ne(c);
    throw Error.captureStackTrace && Error.captureStackTrace(h, a), h;
  }
  const a = async function(f, h = {}) {
    var u;
    const o = {
      request: f,
      options: Fe(h, e.defaults, r),
      response: void 0,
      error: void 0
    };
    if (o.options.method = (u = o.options.method) == null ? void 0 : u.toUpperCase(), o.options.onRequest && await o.options.onRequest(o), typeof o.request == "string" && (o.options.baseURL && (o.request = Ce(o.request, o.options.baseURL)), (o.options.query || o.options.params) && (o.request = Te(o.request, {
      ...o.options.params,
      ...o.options.query
    }))), o.options.body && O(o.options.method) && (Ue(o.options.body) ? (o.options.body = typeof o.options.body == "string" ? o.options.body : JSON.stringify(o.options.body), o.options.headers = new r(o.options.headers || {}), o.options.headers.has("content-type") || o.options.headers.set("content-type", "application/json"), o.options.headers.has("accept") || o.options.headers.set("accept", "application/json")) : (
      // ReadableStream Body
      ("pipeTo" in o.options.body && typeof o.options.body.pipeTo == "function" || // Node.js Stream Body
      typeof o.options.body.pipe == "function") && ("duplex" in o.options || (o.options.duplex = "half"))
    )), !o.options.signal && o.options.timeout) {
      const p = new s();
      setTimeout(() => p.abort(), o.options.timeout), o.options.signal = p.signal;
    }
    try {
      o.response = await t(
        o.request,
        o.options
      );
    } catch (p) {
      return o.error = p, o.options.onRequestError && await o.options.onRequestError(o), await n(o);
    }
    if (o.response.body && !De.has(o.response.status) && o.options.method !== "HEAD") {
      const p = (o.options.parseResponse ? "json" : o.options.responseType) || ze(o.response.headers.get("content-type") || "");
      switch (p) {
        case "json": {
          const m = await o.response.text(), Z = o.options.parseResponse || oe;
          o.response._data = Z(m);
          break;
        }
        case "stream": {
          o.response._data = o.response.body;
          break;
        }
        default:
          o.response._data = await o.response[p]();
      }
    }
    return o.options.onResponse && await o.options.onResponse(o), !o.options.ignoreResponseError && o.response.status >= 400 && o.response.status < 600 ? (o.options.onResponseError && await o.options.onResponseError(o), await n(o)) : o.response;
  }, i = async function(f, h) {
    return (await a(f, h))._data;
  };
  return i.raw = a, i.native = (...c) => t(...c), i.create = (c = {}) => V({
    ...e,
    defaults: {
      ...e.defaults,
      ...c
    }
  }), i;
}
const T = function() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}(), Me = T.fetch || (() => Promise.reject(new Error("[ofetch] global.fetch is not supported!"))), Ge = T.Headers, Je = T.AbortController, Ke = V({ fetch: Me, Headers: Ge, AbortController: Je });
function Ve(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var L = { exports: {} };
const W = (e) => typeof e == "object" && e !== null, Q = Symbol("skip"), $ = (e) => W(e) && !(e instanceof RegExp) && !(e instanceof Error) && !(e instanceof Date), b = (e, t, r, s = /* @__PURE__ */ new WeakMap()) => {
  if (r = {
    deep: !1,
    target: {},
    ...r
  }, s.has(e))
    return s.get(e);
  s.set(e, r.target);
  const { target: n } = r;
  delete r.target;
  const a = (i) => i.map((c) => $(c) ? b(c, t, r, s) : c);
  if (Array.isArray(e))
    return a(e);
  for (const [i, c] of Object.entries(e)) {
    const f = t(i, c, e);
    if (f === Q)
      continue;
    let [h, o, { shouldRecurse: l = !0 } = {}] = f;
    h !== "__proto__" && (r.deep && l && $(o) && (o = Array.isArray(o) ? a(o) : b(o, t, r, s)), n[h] = o);
  }
  return n;
};
L.exports = (e, t, r) => {
  if (!W(e))
    throw new TypeError(`Expected an object, got \`${e}\` (${typeof e})`);
  return b(e, t, r);
};
L.exports.mapObjectSkip = Q;
var We = L.exports;
const x = /* @__PURE__ */ Ve(We);
class H extends Map {
  constructor(t = {}) {
    if (super(), !(t.maxSize && t.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof t.maxAge == "number" && t.maxAge === 0)
      throw new TypeError("`maxAge` must be a number greater than 0");
    this.maxSize = t.maxSize, this.maxAge = t.maxAge || Number.POSITIVE_INFINITY, this.onEviction = t.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  // TODO: Use private class methods when targeting Node.js 16.
  _emitEvictions(t) {
    if (typeof this.onEviction == "function")
      for (const [r, s] of t)
        this.onEviction(r, s.value);
  }
  _deleteIfExpired(t, r) {
    return typeof r.expiry == "number" && r.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(t, r.value), this.delete(t)) : !1;
  }
  _getOrDeleteIfExpired(t, r) {
    if (this._deleteIfExpired(t, r) === !1)
      return r.value;
  }
  _getItemValue(t, r) {
    return r.expiry ? this._getOrDeleteIfExpired(t, r) : r.value;
  }
  _peek(t, r) {
    const s = r.get(t);
    return this._getItemValue(t, s);
  }
  _set(t, r) {
    this.cache.set(t, r), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
  _moveToRecent(t, r) {
    this.oldCache.delete(t), this._set(t, r);
  }
  *_entriesAscending() {
    for (const t of this.oldCache) {
      const [r, s] = t;
      this.cache.has(r) || this._deleteIfExpired(r, s) === !1 && (yield t);
    }
    for (const t of this.cache) {
      const [r, s] = t;
      this._deleteIfExpired(r, s) === !1 && (yield t);
    }
  }
  get(t) {
    if (this.cache.has(t)) {
      const r = this.cache.get(t);
      return this._getItemValue(t, r);
    }
    if (this.oldCache.has(t)) {
      const r = this.oldCache.get(t);
      if (this._deleteIfExpired(t, r) === !1)
        return this._moveToRecent(t, r), r.value;
    }
  }
  set(t, r, { maxAge: s = this.maxAge } = {}) {
    const n = typeof s == "number" && s !== Number.POSITIVE_INFINITY ? Date.now() + s : void 0;
    return this.cache.has(t) ? this.cache.set(t, {
      value: r,
      expiry: n
    }) : this._set(t, { value: r, expiry: n }), this;
  }
  has(t) {
    return this.cache.has(t) ? !this._deleteIfExpired(t, this.cache.get(t)) : this.oldCache.has(t) ? !this._deleteIfExpired(t, this.oldCache.get(t)) : !1;
  }
  peek(t) {
    if (this.cache.has(t))
      return this._peek(t, this.cache);
    if (this.oldCache.has(t))
      return this._peek(t, this.oldCache);
  }
  delete(t) {
    const r = this.cache.delete(t);
    return r && this._size--, this.oldCache.delete(t) || r;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  resize(t) {
    if (!(t && t > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    const r = [...this._entriesAscending()], s = r.length - t;
    s < 0 ? (this.cache = new Map(r), this.oldCache = /* @__PURE__ */ new Map(), this._size = r.length) : (s > 0 && this._emitEvictions(r.slice(0, s)), this.oldCache = new Map(r.slice(s)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = t;
  }
  *keys() {
    for (const [t] of this)
      yield t;
  }
  *values() {
    for (const [, t] of this)
      yield t;
  }
  *[Symbol.iterator]() {
    for (const t of this.cache) {
      const [r, s] = t;
      this._deleteIfExpired(r, s) === !1 && (yield [r, s.value]);
    }
    for (const t of this.oldCache) {
      const [r, s] = t;
      this.cache.has(r) || this._deleteIfExpired(r, s) === !1 && (yield [r, s.value]);
    }
  }
  *entriesDescending() {
    let t = [...this.cache];
    for (let r = t.length - 1; r >= 0; --r) {
      const s = t[r], [n, a] = s;
      this._deleteIfExpired(n, a) === !1 && (yield [n, a.value]);
    }
    t = [...this.oldCache];
    for (let r = t.length - 1; r >= 0; --r) {
      const s = t[r], [n, a] = s;
      this.cache.has(n) || this._deleteIfExpired(n, a) === !1 && (yield [n, a.value]);
    }
  }
  *entriesAscending() {
    for (const [t, r] of this._entriesAscending())
      yield [t, r.value];
  }
  get size() {
    if (!this._size)
      return this.oldCache.size;
    let t = 0;
    for (const r of this.oldCache.keys())
      this.cache.has(r) || t++;
    return Math.min(this._size + t, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(t, r = this) {
    for (const [s, n] of this.entriesAscending())
      t.call(r, n, s, this);
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
}
const Qe = (e, t) => (e = e.replace(
  new RegExp("((?<![\\p{Uppercase_Letter}\\d])[\\p{Uppercase_Letter}\\d](?![\\p{Uppercase_Letter}\\d]))", "gu"),
  (r) => r.toLowerCase()
), e.replace(
  new RegExp("(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)", "gu"),
  (r, s, n) => s + t + n.toLowerCase()
));
function He(e, {
  separator: t = "_",
  preserveConsecutiveUppercase: r = !1
} = {}) {
  if (!(typeof e == "string" && typeof t == "string"))
    throw new TypeError(
      "The `text` and `separator` arguments should be of type `string`"
    );
  if (e.length < 2)
    return r ? e : e.toLowerCase();
  const s = `$1${t}$2`, n = e.replace(
    new RegExp("([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})", "gu"),
    s
  );
  return r ? Qe(n, t) : n.replace(
    new RegExp("(\\p{Uppercase_Letter})(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)", "gu"),
    s
  ).toLowerCase();
}
const Be = (e, t) => e.some((r) => typeof r == "string" ? r === t : (r.lastIndex = 0, r.test(t))), _ = new H({ maxSize: 1e5 }), N = (e) => typeof e == "object" && e !== null && !(e instanceof RegExp) && !(e instanceof Error) && !(e instanceof Date), P = (e, t = {}) => {
  if (!N(e))
    return e;
  const {
    separator: r = "_",
    exclude: s,
    deep: n = !1
  } = t, a = (i) => (c, f) => {
    if (n && N(f) && (f = x(f, a())), !(s && Be(s, c))) {
      const h = `${r}${c}`;
      if (_.has(h))
        c = _.get(h);
      else {
        const o = He(c, { separator: r });
        c.length < 100 && _.set(h, o), c = o;
      }
    }
    return [c, f];
  };
  return x(e, a());
};
function Ye(e, t) {
  return Array.isArray(e) ? Object.keys(e).map((r) => P(e[r], t)) : P(e, t);
}
function Xe(e) {
  return Ye(e, { deep: !0 });
}
function U(e) {
  let t = e;
  for (; t.indexOf("/") >= 0; )
    t = t.replace("/", "_");
  for (; t.indexOf("+") >= 0; )
    t = t.replace("+", "-");
  for (; t.indexOf("=") >= 0; )
    t = t.replace("=", "");
  return t;
}
function d(e, t) {
  const r = e.replace(/{([a-zA-Z0-9_]+)}/g, (s, n) => {
    var i, c;
    const a = (i = t == null ? void 0 : t.query) == null ? void 0 : i[n];
    if (!a)
      throw new Error(`Missing value for path parameter "${n}"`);
    return (c = t == null ? void 0 : t.query) == null || delete c[n], U(a);
  });
  if (t != null && t.query) {
    for (const s in t.query) {
      const n = t.query[s];
      typeof n == "string" && (t.query[s] = U(n));
    }
    t.query = Xe(t.query);
  }
  return [r, t];
}
const B = (e) => typeof e == "object" && e !== null, j = (e) => B(e) && !(e instanceof RegExp) && !(e instanceof Error) && !(e instanceof Date), Ze = Symbol("mapObjectSkip"), R = (e, t, r, s = /* @__PURE__ */ new WeakMap()) => {
  if (r = {
    deep: !1,
    target: {},
    ...r
  }, s.has(e))
    return s.get(e);
  s.set(e, r.target);
  const { target: n } = r;
  delete r.target;
  const a = (i) => i.map((c) => j(c) ? R(c, t, r, s) : c);
  if (Array.isArray(e))
    return a(e);
  for (const [i, c] of Object.entries(e)) {
    const f = t(i, c, e);
    if (f === Ze)
      continue;
    let [h, o, { shouldRecurse: l = !0 } = {}] = f;
    h !== "__proto__" && (r.deep && l && j(o) && (o = Array.isArray(o) ? a(o) : R(o, t, r, s)), n[h] = o);
  }
  return n;
};
function q(e, t, r) {
  if (!B(e))
    throw new TypeError(`Expected an object, got \`${e}\` (${typeof e})`);
  return R(e, t, r);
}
const ke = /[\p{Lu}]/u, et = /[\p{Ll}]/u, z = /^[\p{Lu}](?![\p{Lu}])/gu, Y = /([\p{Alpha}\p{N}_]|$)/u, I = /[_.\- ]+/, tt = new RegExp("^" + I.source), F = new RegExp(I.source + Y.source, "gu"), v = new RegExp("\\d+" + Y.source, "gu"), rt = (e, t, r, s) => {
  let n = !1, a = !1, i = !1, c = !1;
  for (let f = 0; f < e.length; f++) {
    const h = e[f];
    c = f > 2 ? e[f - 3] === "-" : !0, n && ke.test(h) ? (e = e.slice(0, f) + "-" + e.slice(f), n = !1, i = a, a = !0, f++) : a && i && et.test(h) && (!c || s) ? (e = e.slice(0, f - 1) + "-" + e.slice(f - 1), i = a, a = !1, n = !0) : (n = t(h) === h && r(h) !== h, i = a, a = r(h) === h && t(h) !== h);
  }
  return e;
}, st = (e, t) => (z.lastIndex = 0, e.replaceAll(z, (r) => t(r))), ot = (e, t) => (F.lastIndex = 0, v.lastIndex = 0, e.replaceAll(v, (r, s, n) => ["_", "-"].includes(e.charAt(n + r.length)) ? r : t(r)).replaceAll(F, (r, s) => t(s)));
function nt(e, t) {
  if (!(typeof e == "string" || Array.isArray(e)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (t = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...t
  }, Array.isArray(e) ? e = e.map((a) => a.trim()).filter((a) => a.length).join("-") : e = e.trim(), e.length === 0)
    return "";
  const r = t.locale === !1 ? (a) => a.toLowerCase() : (a) => a.toLocaleLowerCase(t.locale), s = t.locale === !1 ? (a) => a.toUpperCase() : (a) => a.toLocaleUpperCase(t.locale);
  return e.length === 1 ? I.test(e) ? "" : t.pascalCase ? s(e) : r(e) : (e !== r(e) && (e = rt(e, r, s, t.preserveConsecutiveUppercase)), e = e.replace(tt, ""), e = t.preserveConsecutiveUppercase ? st(e, r) : r(e), t.pascalCase && (e = s(e.charAt(0)) + e.slice(1)), ot(e, s));
}
const at = (e, t) => e.some((r) => typeof r == "string" ? r === t : (r.lastIndex = 0, r.test(t))), E = new H({ maxSize: 1e5 }), D = (e) => typeof e == "object" && e !== null && !(e instanceof RegExp) && !(e instanceof Error) && !(e instanceof Date), M = (e, t = {}) => {
  if (!D(e))
    return e;
  const {
    exclude: r,
    pascalCase: s = !1,
    stopPaths: n,
    deep: a = !1,
    preserveConsecutiveUppercase: i = !1
  } = t, c = new Set(n), f = (h) => (o, l) => {
    if (a && D(l)) {
      const u = h === void 0 ? o : `${h}.${o}`;
      c.has(u) || (l = q(l, f(u)));
    }
    if (!(r && at(r, o))) {
      const u = s ? `${o}_` : o;
      if (E.has(u))
        o = E.get(u);
      else {
        const p = nt(o, { pascalCase: s, locale: !1, preserveConsecutiveUppercase: i });
        o.length < 100 && E.set(u, p), o = p;
      }
    }
    return [o, l];
  };
  return q(e, f(void 0));
};
function ct(e, t) {
  return Array.isArray(e) ? Object.keys(e).map((r) => M(e[r], t)) : M(e, t);
}
function it(e) {
  return ct(e, { deep: !0 });
}
function X(e) {
  const t = {};
  for (const r in e) {
    const s = e[r];
    t[r] = s === null ? void 0 : s && typeof s == "object" && s.__proto__.constructor === Object ? X(s) : s;
  }
  return t;
}
function y(e) {
  return X(it(e));
}
class ft {
  constructor(t) {
    const r = new URL((t == null ? void 0 : t.baseUrl) ?? "https://api.ston.fi"), s = [...new URLSearchParams(r.search)].reduce(
      // biome-ignore lint/performance/noAccumulatingSpread: it's ok here
      (n, [a, i]) => ({ ...n, [a]: i }),
      {}
    );
    this.apiFetch = Ke.create({
      baseURL: `${r.origin}${r.pathname}`,
      query: s
    });
  }
  async getAssets() {
    return y(
      await this.apiFetch(
        ...d("/v1/assets", {
          method: "GET"
        })
      )
    ).assetList;
  }
  async getFarms() {
    return y(
      await this.apiFetch(
        ...d("/v1/farms", {
          method: "GET"
        })
      )
    ).farmList;
  }
  async getPools() {
    return y(
      await this.apiFetch(
        ...d("/v1/pools", {
          method: "GET"
        })
      )
    ).poolList;
  }
  async getJettonWalletAddress(t) {
    return y(
      await this.apiFetch(
        ...d("/v1/jetton/{jettonAddress}/address", {
          method: "GET",
          query: t
        })
      )
    ).address;
  }
  async getWalletAssets(t) {
    return y(
      await this.apiFetch(
        ...d("/v1/wallets/{walletAddress}/assets", {
          method: "GET",
          query: { walletAddress: t }
        })
      )
    ).assetList;
  }
  async getWalletFarms(t) {
    return y(
      await this.apiFetch(
        ...d("/v1/wallets/{walletAddress}/farm", {
          method: "GET",
          query: { walletAddress: t }
        })
      )
    ).farmList;
  }
  async getWalletPools(t) {
    return y(
      await this.apiFetch(
        ...d("/v1/wallets/{walletAddress}/pools", {
          method: "GET",
          query: { walletAddress: t }
        })
      )
    ).poolList;
  }
}
const ht = {
  Ton: "Ton",
  Wton: "Wton",
  Jetton: "Jetton"
};
export {
  ht as AssetKind,
  ft as StonApiClient
};
//# sourceMappingURL=index.js.map
